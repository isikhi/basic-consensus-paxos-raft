const langData = {
    tr: {
        pageTitle: "Konsensüs Algoritması Görselleştirici: Paxos vs Raft",
        languageLabel: "Dil:",
        mainTitle: "Konsensüs Algoritması Görselleştirici: Paxos vs Raft",
        tabOverview: "Genel Bakış",
        tabVisualization: "Görselleştirme",
        tabComparison: "Detaylı Karşılaştırma",
        overviewTitle: "Konsensüs Algoritmalarını Anlama: Temeller ve Teknik İhtiyaç",
        overviewIntro: "Dağıtık sistemlerde, birden fazla makinenin ağ sorunları ya da makine arızaları gibi problemlere rağmen ortak bir veri veya durum üzerinde anlaşması gerekir. İşte bu 'anlaşma' problemini konsensüs algoritmaları çözer. Örneğin, bir veritabanı kümesindeki (cluster) tüm kopyaların aynı veriyi görmesi, bir koordinasyon servisinin (ZooKeeper, etcd gibi) tutarlı çalışması veya blockchain'deki işlemlerin sırasının belirlenmesi bu algoritmalar sayesinde mümkün olur. Temelde yaptıkları iş <strong>Durum Makinesi Çoğaltması (State Machine Replication - SMR)</strong> olarak bilinir: Tüm kopyaların (replica) gelen komutları aynı sırada işlemesini sağlayarak, hepsinin aynı durumda kalmasını ve sistemin tutarlı çalışmasını garanti ederler. <strong>Paxos</strong>, bu alandaki ilk ve teorik olarak sağlam algoritmalardan biridir, ancak anlaşılması ve uygulanması zordur. Bu zorluk, daha anlaşılır ve uygulaması kolay olması hedeflenen <strong>Raft</strong> gibi alternatiflerin geliştirilmesine yol açmıştır. Raft bu yüzden modern sistemlerde sıkça tercih edilir. Bunların dışında <strong>Zab</strong> (özellikle ZooKeeper için) veya <strong>Viewstamped Replication (VR)</strong> gibi başka algoritmalar da vardır. Bu algoritmalar; lider seçimi, logların kopyalanması, güvenlik mekanizmaları ve mesajlaşma gibi konularda farklı yaklaşımlar benimserler, bu da performanslarını ve karmaşıklıklarını etkiler.",
        paxosDesc: "Teorik sağlamlığı kanıtlanmış ilk yaygın konsensüs algoritmalarından biridir. Esnektir ancak tam olarak anlaşılması ve hatasız uygulanması zordur, özellikle Multi-Paxos (log çoğaltma için) varyantı.",
        paxosRoles: "<strong>Roller:</strong> Proposer (Teklif eden), Acceptor (Kabul eden), Learner (Öğrenen). Roller bir node üzerinde birleşebilir.",
        paxosProtocol: "<strong>Protokol:</strong> Temelde iki aşamalıdır: Prepare/Promise (Hazırlık/Söz) ve Accept/Accepted (Kabul Et/Kabul Edildi).",
        paxosLeadership: "<strong>Liderlik:</strong> Açıkça tanımlanmış sürekli bir lider yoktur, ancak pratikte performansı artırmak için genellikle \"seçkin\" bir Proposer kullanılır. Liderlik yarışı ve çakışmalar yaşanabilir.",
        paxosComplexity: "<strong>Karmaşıklık:</strong> Teorik temeli güçlü olsa da, tüm köşe durumlarını doğru ele almak ve uygulamak zordur.",
        raftDesc: "Paxos'a alternatif olarak, anlaşılabilirliği ve implementasyon kolaylığını hedefleyerek tasarlanmıştır. Durum makinesi çoğaltması için bütünlüklü bir çözüm sunar.",
        raftRoles: "<strong>Roller:</strong> Leader (Lider), Candidate (Aday), Follower (Takipçi). Her node bu rollerden birinde bulunur.",
        raftProtocol: "<strong>Protokol:</strong> Ana parçaları Lider Seçimi (Leader Election), Log Replikasyonu (Log Replication) ve Güvenlik (Safety) mekanizmalarıdır.",
        raftLeadership: "<strong>Liderlik:</strong> Güçlü ve tek bir lider vardır. Lider çökerse, yeni bir seçim süreci başlar. Tüm işlemler lider üzerinden akar.",
        raftUnderstandability: "<strong>Anlaşılabilirlik:</strong> Protokol, anlaşılması daha kolay olacak şekilde parçalara ayrılmıştır.",
        keyCharacteristics: "Temel Özellikler Özeti",
        tableFeature: "Özellik",
        tableLeadership: "Liderlik",
        paxosLeadershipVal: "Açık lider yok (pratikte seçkin proposer kullanılır)",
        raftLeadershipVal: "Güçlü, tek ve açık lider",
        tableProtocol: "Protokol Yapısı",
        paxosProtocolVal: "İki ana faz (Prepare/Promise, Accept/Accepted)",
        raftProtocolVal: "Lider seçimi, Log replikasyonu, Güvenlik",
        tableFaultTolerance: "Hata Toleransı",
        paxosFaultToleranceVal: "f hatayı tolere etmek için 2f+1 node gerekir",
        raftFaultToleranceVal: "f hatayı tolere etmek için 2f+1 node gerekir",
        tableComplexity: "Uygulama Karmaşıklığı",
        paxosComplexityVal: "Yüksek",
        raftComplexityVal: "Orta (Paxos'a göre daha kolay)",
        tableUnderstandability: "Anlaşılabilirlik",
        paxosUnderstandabilityVal: "Karmaşık",
        raftUnderstandabilityVal: "Anlaşılabilirlik için tasarlandı",
        tableMessageComplexity: "Mesaj Karmaşıklığı",
        paxosMessageComplexityVal: "Normal durumda daha fazla mesaj (lidersiz)",
        raftMessageComplexityVal: "Lider sayesinde daha az mesaj (ama heartbeat trafiği var)",
        tableKeyAdvantage: "Temel Avantaj",
        paxosKeyAdvantageVal: "Teorik temel, esneklik",
        raftKeyAdvantageVal: "Anlaşılması ve uygulanması daha kolay",
        goToVisualizationBtn: "Etkileşimli Görselleştirmeye Git →",
        disclaimerTitle: "Uyarı",
        disclaimerText: "Bu görselleştirme, Paxos ve Raft'ın temel akışını ve iletisim türlerini göstermektedir. Burada gösterilen simülasyonun mantığı <strong>çok basitleştirilmiştir</strong> ve zaman aşımları, yeterli sayı (quorum) kuralları, log eşleştirme, dinamik teklif numaraları veya ayrıntılı hata senaryolari gibi mekanizmalar tam olarak gösterilmez. Kavramsal anlama için yapılmıştır, canlı sistemlerde uygulamak için tamamen doğru bir simülasyon olarak değildir.",
        visualizationTitle: "Algoritma Görselleştirmesi",
        algoComp: "Yan Yana",
        algoPaxos: "Sadece Paxos",
        algoRaft: "Sadece Raft",
        scenarioLabel: "Senaryo:",
        scenarioNormal: "Normal Operasyon",
        scenarioNodeFailure: "Düğüm Hatası (Basit)",
        scenarioLeaderFailure: "Lider/Teklifçi Hatası (Kurtarma Denemesi)",
        stepLabel: "Adım:",
        prevBtn: "Önceki",
        nextBtn: "Sonraki",
        resetBtn: "Sıfırla",
        legendTitle: "Lejant",
        legendPaxosTitle: "Paxos Rolleri",
        legendProposer: "Teklifçi (Proposer)",
        legendAcceptor: "Kabul Eden (Acceptor)",
        legendLearner: "Öğrenen (Learner)",
        legendRaftTitle: "Raft Rolleri/Durumları",
        legendLeader: "Lider (Leader)",
        legendCandidate: "Aday (Candidate)",
        legendFollower: "Takipçi (Follower)",
        legendStatesTitle: "Ortak Durumlar",
        legendPreparing: "Hazırlanıyor (Paxos)",
        legendPromised: "Söz Verdi (Paxos)",
        legendAccepted: "Kabul Etti (Paxos)",
        legendFailed: "Başarısız/Pasif",
        logTitle: "Simülasyon Logları",
        comparisonTitle: "Detaylı Karşılaştırma: Paxos vs Raft",
        comparisonIntro: "Her iki algoritma da dağıtık sistemlerde konsensüs sağlasa ve `f` hatayı tolere edebilse de, yaklaşımları, karmaşıklıkları ve operasyonel özellikleri açısından önemli ölçüde farklılık gösterirler.",
        compAspect: "Yön",
        compLeadership: "Liderlik",
        compPaxosLeadershipVal: "Doğal bir lider yoktur. Herhangi bir teklifçi başlatabilir. Genellikle bir lideri taklit eden \"seçkin bir teklifçi\" ile optimize edilir, ancak liderlik örtük ve çekişmeli bir şekilde değişebilir.",
        compRaftLeadershipVal: "Belirli bir dönem için açıkça seçilmiş güçlü, tek bir lider vardır. Tüm istemci istekleri ve log replikasyonu lider üzerinden akar. Lider hatası yeni bir seçimi tetikler.",
        compPhases: "Protokol Aşamaları",
        compPaxosPhasesVal: "Aşama 1: Hazırlık/Söz (liderliği/teklif numarasını talep etme). Aşama 2: Kabul Et/Kabul Edildi (değeri teklif etme ve onaylama). Tek bir konsensüs örneği için birden fazla tur gerçekleşebilir.",
        compRaftPhasesVal: "Lider Seçimi (dönemler ve oylama kullanarak), Log Replikasyonu (lider, AppendEntries RPC'leri aracılığıyla takipçilere girdileri gönderir, kalp atışları dahil), Güvenlik (tutarlılığı sağlayan kurallar, örn. lider bütünlüğü).",
        compComplexity: "Karmaşıklık & Anlaşılabilirlik",
        compPaxosComplexityVal: "Yüksek. İnce etkileşimler ve çok sayıda köşe durumu (örn. düello yapan teklifçiler) nedeniyle tam olarak anlaşılması ve doğru uygulanması zor kabul edilir. Multi-Paxos varyantları daha fazla karmaşıklık ekler.",
        compRaftComplexityVal: "Orta. Özellikle anlaşılabilirlik için tasarlanmıştır. Lider seçimi, log replikasyonu ve güvenliğe ayrıştırılması, kavramayı ve uygulamayı kolaylaştırır.",
        compFaultTolerance: "Hata Toleransı Mekanizması",
        compPaxosFaultToleranceVal: "Sadece bir değerin seçilebilmesini sağlamak için yanıt veren kabul edenlerin çakışan yeter sayısına (çoğunluk) dayanır. Yeter sayısı korunursa düğüm hatalarını ve mesaj kaybını/yeniden sıralanmasını tolere eder. (f hatayı tolere etmek için 2f+1 node gerekir)",
        compRaftFaultToleranceVal: "Dönemlerle lider seçimine, seçimler için çoğunluk oylamasına ve log girdisi taahhüdü için çoğunluk onayına dayanır. Zaman aşımları lider hatalarını algılar. Log eşleştirme özelliği tutarlılığı sağlar. (f hatayı tolere etmek için 2f+1 node gerekir)",
        compPerformance: "Performans",
        compPaxosPerformanceVal: "Stabil bir lider (seçkin teklifçi) kurulursa (tek gidiş-dönüşe yaklaşarak) stabil koşullarda potansiyel olarak daha hızlı konsensüs sağlayabilir. Teklifçi çakışmaları sırasında performans düşüşü yaşayabilir.",
        compRaftPerformanceVal: "Açık bir lider altında stabil performans. Hataler meydana geldiğinde lider seçimi gecikme ekler. Log replikasyon yükü komutların hızına bağlıdır.",
        compFlexibility: "Esneklik",
        compPaxosFlexibilityVal: "Teoride daha esnek; kesinlikle bir lider gerektirmez. Potansiyel olarak belirli ağ koşullarını veya hata modlarını farklı şekilde ele alabilir.",
        compRaftFlexibilityVal: "Güçlü lider modeli nedeniyle daha az esnek. Küme üyelik değişikliklerini basitleştirir (yine de karmaşık olsa da).",
        compUseCases: "Kullanım Alanları",
        compPaxosUseCasesVal: "Google'ın Chubby (Paxos tabanlı), Spanner (Paxos benzeri protokol kullanır) gibi temel sistemlerde kullanılır. Genellikle teorik garantilerin çok önemli olduğu veya mevcut uzmanlığın bulunduğu durumlarda seçilir.",
        compRaftUseCasesVal: "etcd (Kubernetes), Consul, CockroachDB, TiDB gibi modern sistemlerde yaygın olarak benimsenmiştir. Anlama, uygulama ve bakım kolaylığının öncelikli olduğu durumlarda tercih edilir.",
        advDisadvTitle: "Avantajlar & Dezavantajlar",
        advantages: "Avantajlar:",
        paxosAdv1: "Güçlü teorik temel, matematiksel olarak kanıtlanmış.",
        paxosAdv2: "Ağ koşullarında potansiyel olarak daha yüksek esneklik (kesin lider bağımlılığı yok).",
        paxosAdv3: "Stabil bir seçkin teklifçi ile düşük gecikme süresi elde edebilir.",
        disadvantages: "Dezavantajlar:",
        paxosDisadv1: "Anlaşılması ve doğru uygulanması önemli ölçüde daha zor.",
        paxosDisadv2: "Özellikle teklifçi çakışmaları sırasında daha yüksek mesaj karmaşıklığı mümkün.",
        paxosDisadv3: "Temel Paxos sadece bir değere karar verir; bir log için Multi-Paxos gerekir, bu da karmaşıklığı artırır.",
        raftAdv1: "Paxos'a kıyasla anlaşılması ve uygulanması çok daha kolay.",
        raftAdv2: "Açık lider, sistem tasarımını ve mantığını basitleştirir.",
        raftAdv3: "Çoğaltılmış bir log yönetmek için eksiksiz bir çözüm sunar.",
        raftAdv4: "Lider hatasını ve küme değişikliklerini ele almak için net mekanizmalar (karmaşık olsa da).",
        raftDisadv1: "Lider hatası, seçim sırasında geçici kullanılamazlığa neden olur.",
        raftDisadv2: "Güçlü lider bağımlılığı, bazı özel ağ bölümleme senaryolarında lidersiz bir yaklaşıma göre daha az optimal olabilir.",
        raftDisadv3: "Performans, tek liderin kapasitesine bağlıdır.",
        glossaryTitle: "Sözlük",
        glossaryNodeIdTitle: "Düğüm Tanımlayıcılar:",
        glossaryP1Pn: "<strong>P1, Pn...:</strong> Paxos simülasyonundaki düğümleri (Proposer, Acceptor, Learner) temsil eder. Örneğin, P1, ID'si 1 olan Paxos düğümüdür.",
        glossaryR1Rn: "<strong>R1, Rn...:</strong> Raft simülasyonundaki düğümleri (Follower, Candidate, Leader) temsil eder. Örneğin, R1, ID'si 1 olan Raft düğümüdür.",
        glossaryTermIdTitle: "Terim Tanımlayıcı:",
        glossaryT0Tn: "<strong>T0, Tn...:</strong> Raft algoritmasındaki 'Term' (Dönem) numarasını gösterir. Her liderlik seçimi yeni bir dönem başlatır ve dönem numarası artar. Örneğin, T=1, 1. dönemi ifade eder.",
        glossaryPaxosRolesTitle: "Paxos Rolleri:",
        glossaryProposer: "<strong>Proposer (Teklifçi):</strong> Konsensüs sürecini başlatan ve bir değer teklif eden düğüm.",
        glossaryAcceptor: "<strong>Acceptor (Kabul Eden):</strong> Teklifleri alan, değerlendiren ve kabul eden düğümler. Karar yeter sayısına (quorum) göre verilir.",
        glossaryLearner: "<strong>Learner (Öğrenen):</strong> Konsensüs sonucunda kabul edilen değeri öğrenen düğüm(ler).",
        glossaryRaftRolesTitle: "Raft Rolleri/Durumları:",
        glossaryFollower: "<strong>Follower (Takipçi):</strong> Pasif olarak liderden mesajları (AppendEntries/Heartbeat) bekleyen ve liderin veya adayların isteklerine yanıt veren düğüm.",
        glossaryCandidate: "<strong>Candidate (Aday):</strong> Lider seçimi sırasında oy isteyen düğüm. Yeterli oy alırsa Lider olur.",
        glossaryLeader: "<strong>Leader (Lider):</strong> Tüm istemci isteklerini yöneten, log girdilerini takipçilere kopyalayan ve heartbeat gönderen tekil düğüm.",
        glossaryPaxosMessagesTitle: "Paxos Mesajları/Kavramları:",
        glossaryPrepare: "<strong>Prepare(n=X):</strong> Proposer'ın belirli bir teklif numarası (n=X) ile yeni bir teklif turu başlatmak için Acceptor'lara gönderdiği mesaj.",
        glossaryPromise: "<strong>Promise(n=X):</strong> Acceptor'ın, Proposer'dan aldığı Prepare(n=X) mesajına yanıt olarak, X'ten daha düşük numaralı teklifleri kabul etmeyeceğine dair verdiği söz. Daha önce kabul ettiği bir değer varsa onu da bildirir.",
        glossaryAccept: "<strong>Accept(n=X, v=Y):</strong> Proposer'ın, yeterli sayıda Promise aldıktan sonra, belirli bir teklif numarası (n=X) ve değer (v=Y) ile Acceptor'lara gönderdiği kabul talebi.",
        glossaryAccepted: "<strong>Accepted(n=X, v=Y):</strong> Acceptor'ın, Accept talebini kabul ettiğini ve değeri (v=Y) benimsediğini Learner'lara bildirdiği mesaj.",
        glossaryRaftMessagesTitle: "Raft Mesajları/Kavramları:",
        glossaryRequestVote: "<strong>RequestVote(term=X):</strong> Bir Candidate'in, yeni bir lider seçimi için diğer düğümlerden kendi lehine oy istediği mesaj. Mesaj, adayın dönem numarasını (term=X) içerir.",
        glossaryVoteGranted: "<strong>VoteGranted(term=X, granted=Y):</strong> Bir düğümün, RequestVote mesajına yanıt olarak oy verip vermediğini (granted=true/false) ve kendi güncel dönemini (term=X) bildirdiği mesaj.",
        glossaryAppendEntries: "<strong>AppendEntries(term=X, entries=[]):</strong> Liderin takipçilere log girdilerini kopyalamak için gönderdiği mesaj. Eğer `entries` boşsa, bu mesaj 'Heartbeat' olarak işlev görür ve liderin hayatta olduğunu belirtir. Mesaj, liderin dönemini (term=X) içerir.",
        glossaryTerm: "<strong>term=X:</strong> Raft'ta zamanı mantıksal dönemlere (Term) ayıran sayaç. Her seçim yeni bir dönemle başlar ve dönem numarası artar. Bu, eski liderleri veya adayları tespit etmek için kullanılır.",
        glossaryQuorumTitle: "Çoğunluk (Quorum):",
        glossaryQuorumDesc: "Dağıtık bir sistemde, bir işlemin (örneğin bir kararın alınması veya lider seçimi) geçerli sayılabilmesi için gereken minimum düğüm (veya oy) sayısıdır. Genellikle, çelişkili kararları (split-brain) önlemek için toplam düğüm sayısının yarısından fazlası (> N/2) olarak belirlenir.",
        simulationLogs: {
            raftLeaderFailed: "[Adım {step}] Raft: Lider (Düğüm {leaderId}) senaryo gereği adım {step}'de başarısız oldu! Seçim başlamalı.",
            raftLeaderExists: "[Adım {step}] Raft: Lider (Düğüm {leaderId}, Dönem {term}) mevcut. Başlangıç seçimi gerekli değil.",
            raftCandidateElectedSelf: "[Adım {step}] Raft: Düğüm {nodeId}'in seçim zaman aşımı doldu (simüle edildi). Yeni Dönem {term} için Aday oldu. Kendine oy verdi.",
            raftInitialCandidateInactive: "[Adım {step}] Raft: Başlangıç adayı (Düğüm {nodeId}) aktif değil. Seçim başlatılamıyor.",
            raftLeaderSendsHeartbeats: "[Adım {step}] Raft: Lider (Düğüm {leaderId}, Dönem {term}) aktif. Otoriteyi korumak için kalp atışları gönderiyor.",
            raftLeaderSentHeartbeatsCount: "[Adım {step}] Raft: Lider {leaderId}, {count} aktif takipçiye kalp atışları (AppendEntries) gönderdi.",
            raftLeaderNoFollowers: "[Adım {step}] Raft: Lider {leaderId}'in kalp atışı gönderecek aktif takipçisi yok.",
            raftRecoveryCandidateElectedSelf: "[Adım {step}] Raft: Kurtarma - Düğüm {nodeId}'in seçim zaman aşımı doldu (lider hatası sonrası simüle edildi). Yeni Dönem {term} için Aday oldu. Kendine oy verdi.",
            raftRecoveryNoFollowers: "[Adım {step}] Raft: Kurtarma - Lider hatası sonrası seçimi başlatacak aktif takipçi bulunamadı.",
            raftNoLeaderWaiting: "[Adım {step}] Raft: Lider yok, ancak kurtarma senaryosunda değil (örneğin, başlangıç seçimi başarısız?). Zaman aşımı bekleniyor.",
            raftCandidateRequestingVotes: "[Adım {step}] Raft: Aday {candidateId} (Dönem {term}), {count} diğer aktif düğümden oy istiyor.",
            raftCandidateNoNodesToRequest: "[Adım {step}] Raft: Aday {candidateId} (Dönem {term}), oy isteyecek başka aktif düğüm bulamadı.",
            raftLeaderExistsNoRequestVote: "[Adım {step}] Raft: Lider {leaderId} mevcut. RequestVote gerekli değil.",
            raftRecoveryNoCandidate: "[Adım {step}] Raft: Kurtarma - Oy isteyecek aktif aday bulunamadı. Zaman aşımı bekleniyor (Adım 5 simülasyonu).",
            raftNoCandidateWaiting: "[Adım {step}] Raft: Aktif Aday bulunamadı. Seçim zaman aşımı bekleniyor.",
            raftProcessingRequestVotes: "[Adım {step}] Raft: Adım {prevStep}'den gelen RequestVote mesajları işleniyor.",
            raftVoterInactive: "[Adım {step}] Raft: Oy veren Düğüm {voterId} aktif değil, {candidateId}'den gelen RequestVote işlenemiyor.",
            raftCandidateNotFound: "[Adım {step}] Raft: Aday Düğüm {candidateId} bulunamadı veya aktif değil, oy işlenemiyor.",
            raftVoterUpdatingTerm: "[Adım {step}] Raft: Düğüm {voterId}, Aday {candidateId}'den daha yüksek {newTerm} dönemi aldı. Dönem {oldTerm}'den güncelleniyor, Takipçi oluyor.",
            raftVoteGranted: "[Adım {step}] Raft: Düğüm {voterId}, Aday {candidateId} için Dönem {term}'de OY VERDİ.",
            raftVoteDenied: "[Adım {step}] Raft: Düğüm {voterId}, Aday {candidateId}'ye OY VERMEDİ. Sebep: {reason}.",
            raftVoteDeniedReasonHigherTerm: "Oy verenin dönemi ({voterTerm}) adayın döneminden ({candidateTerm}) yüksek",
            raftVoteDeniedReasonAlreadyVoted: "Dönem {term}'de zaten Düğüm {votedFor}'a oy verildi",
            raftVoteDeniedReasonGeneric: "Dönem uyuşmazlığı veya zaten oy verilmiş",
            raftCandidateVoteSummary: "[Adım {step}] Raft: Aday {candidateId}, Dönem {term}'de şu ana kadar potansiyel olarak {count} oy aldı.",
            raftNoRequestVotesFound: "[Adım {step}] Raft: Adım {prevStep}'den RequestVote mesajı bulunamadı. Seçim takılmış veya bekliyor olabilir.",
            raftLeaderExistsVoteGrantSkipped: "[Adım {step}] Raft: Lider {leaderId} mevcut. Oy verme aşaması atlandı çünkü aktif seçim yok.",
            raftCheckingQuorum: "[Adım {step}] Raft: Herhangi bir adayın Dönem {term}'de yeterli çoğunluğu ({quorum} oy) alıp almadığı kontrol ediliyor (adım {voteStep}'deki oylara göre).",
            raftCandidateVoteCheck: "[Adım {step}] Raft: Aday {candidateId} (Dönem {term}) toplam oy: {totalVotes} (Alınan: {receivedVotes}, Kendi: {selfVote}). Gereken çoğunluk: {quorum}.",
            raftNewLeaderElected: "[Adım {step}] Raft: Düğüm {leaderId} yeterli çoğunluğu ({totalVotes}/{quorum}) aldı. Dönem {term} için LİDER oldu.",
            raftRecoveryElectionSuccess: "[Adım {step}] Raft: (Kurtarma seçimi başarılı!)",
            raftNewLeaderSendsHeartbeats: "[Adım {step}] Raft: Yeni Lider {leaderId}, {count} takipçiye başlangıç kalp atışları gönderdi.",
            raftNewLeaderNoFollowers: "[Adım {step}] Raft: Yeni Lider {leaderId}'in başlangıç kalp atışları için aktif takipçisi yok.",
            raftCandidateNoQuorum: "[Adım {step}] Raft: Aday {candidateId} yeterli çoğunluğu ({totalVotes}/{quorum}) alamadı. Şimdilik Aday olarak kalıyor.",
            raftLeaderFailedMaybe: "[Adım {step}] Raft: Lider {leaderId} mevcuttu ancak bu adımda başarısız olmuş olabilir (eğer senaryo=leaderFailure ise).",
            raftNoQuorumElectionFailed: "[Adım {step}] Raft: Hiçbir aday yeterli çoğunluğu alamadı. Dönem {term} için seçim başarısız oldu. Düğümler Takipçi veya Aday olarak kalıyor.",
            raftNoActiveCandidatesFound: "[Adım {step}] Raft: Dönem {term} için aktif aday bulunamadı.",
            raftScenarioTriggerLeaderFail: "[Adım {step}] Raft: *** SENARYO TETİKLEMESİ *** Yeni seçilen Lider (Düğüm {leaderId}) senaryo gereği şimdi başarısız oluyor!",
            raftLeaderPeriodicHeartbeats: "[Adım {step}] Raft: Lider {leaderId} (Dönem {term}), {count} aktif takipçiye periyodik kalp atışları gönderiyor.",
            raftLeaderPeriodicNoFollowers: "[Adım {step}] Raft: Lider {leaderId}'in periyodik kalp atışları için aktif takipçisi yok.",
            raftFollowerIgnoringOldHeartbeat: "[Adım {step}] Raft: Takipçi {followerId}, eski Lider {leaderId}'den kalp atışı aldı (Dönem {leaderTerm} < {followerTerm}). Yoksayılıyor.",
            raftFollowerUpdatingTermFromHeartbeat: "[Adım {step}] Raft: Takipçi {followerId}, Lider {leaderId}'den kalp atışı alınca dönemi {newTerm}'e güncelledi. votedFor sıfırlanıyor.",
            raftFollowerReceivedHeartbeat: "[Adım {step}] Raft: Takipçi {followerId}, Lider {leaderId}'den kalp atışı aldı. Dönem {term}'de takipçi olarak kalıyor.",
            raftNoLeaderElectionOngoing: "[Adım {step}] Raft: Aktif Lider bulunamadı (önceki adım {failedStep}'de başarısız oldu). Seçim devam ediyor veya başarısız olmuş olabilir.",
            raftNoLeaderElectionFailed: "[Adım {step}] Raft: Aktif Lider bulunamadı. Seçim süreci başarısız olmuş veya zaman aşımı bekleniyor olabilir.",
            raftEndOfSimulation: "[Adım {step}] Raft: Simülasyon adımlarının sonu.",
            raftWaitingNextPhase: "[Adım {step}] Raft: Sonraki aşama veya eylem bekleniyor.",
            paxosProposerFailed: "[Adım {step}] Paxos: Orijinal Teklifçi (Düğüm {proposerId}) senaryo gereği adım {step}'de başarısız oldu!",
            paxosRecoveryProposerTakingOver: "[Adım {step}] Paxos: Kurtarma - Düğüm {proposerId} teklifçi rolünü devralmaya çalışıyor.",
            paxosPrepareSent: "[Adım {step}] Paxos: Teklifçi (Düğüm {proposerId}), {count} aktif kabul ediciye Prepare(n={proposalN}) gönderdi.",
            paxosOriginalProposerFailedOrInactive: "[Adım {step}] Paxos: Orijinal teklifçi adım 1'den önce başarısız oldu veya aktif değil.",
            paxosNoActiveInitialProposer: "[Adım {step}] Paxos: Adım 1 için aktif başlangıç Teklifçisi bulunamadı.",
            paxosRecoveryProposerPrepareSent: "[Adım {step}] Paxos: Kurtarma Teklifçisi (Düğüm {proposerId}), {count} aktif kabul ediciye Prepare(n={proposalN}) gönderdi.",
            paxosRecoveryWaiting: "[Adım {step}] Paxos: Kurtarma - Yeni bir teklifçinin ortaya çıkması bekleniyor veya aktif düğüm yok.",
            paxosOriginalProposerActiveNoAction: "[Adım {step}] Paxos: Adım 5 - Orijinal teklifçi hala aktif. Burada tanımlı bir eylem yok.",
            paxosStep5NoAction: "[Adım {step}] Paxos: Adım 5 - Özel bir eylem tanımlanmadı.",
            paxosAcceptorIgnoringPrepare: "[Adım {step}] Paxos: Kabul Edici {acceptorId}, zaten {promisedN} sözü verdiği için Prepare(n={proposalN}) mesajını yoksaydı.",
            paxosPromisesSent: "[Adım {step}] Paxos: {count} Kabul Edici, Düğüm {proposerId}'e Promise(n={proposalN}) gönderdi.",
            paxosNoPromisesSent: "[Adım {step}] Paxos: Hiçbir Kabul Edici n={proposalN} için Promise göndermedi.",
            paxosNoPrepareMessage: "[Adım {step}] Paxos: Adım {prepareStep}'den yanıt verilecek ilgili Prepare mesajı bulunamadı.",
            paxosProposerGotQuorum: "[Adım {step}] Paxos: Teklifçi (Düğüm {proposerId}), adım {promiseStep}'de yeterli çoğunluktan ({receivedCount}/{quorum}) Promise aldığını doğruladı.",
            paxosProposerNoQuorum: "[Adım {step}] Paxos: Teklifçi (Düğüm {proposerId}), adım {promiseStep}'de yeterli çoğunluktan ({receivedCount}/{quorum}) Promise ALAMADI. Devam edilemiyor.",
            paxosRecoveryProposerFailedOrNoPrepare: "[Adım {step}] Paxos: Kurtarma teklifçisi (Düğüm {proposerId}) başarısız olmuş olabilir veya prepare bulunamadı.",
            paxosProposerInactive: "[Adım {step}] Paxos: Adım {prepareStep}'de Prepare gönderen Teklifçi (Düğüm {proposerId}) artık aktif değil.",
            paxosAcceptSent: "[Adım {step}] Paxos: Teklifçi (Düğüm {proposerId}), aktif kabul edicilere Accept(n={proposalN}, v=\"{value}\") gönderdi.",
            paxosCannotSendAccept: "[Adım {step}] Paxos: Accept mesajı gönderilemiyor.",
            paxosAcceptorIgnoringAccept: "[Adım {step}] Paxos: Kabul Edici {acceptorId}, daha yüksek bir N ({promisedN}) sözü verdiği için Accept(n={proposalN}) mesajını yoksaydı.",
            paxosAcceptedAndNotified: "[Adım {step}] Paxos: {count} Kabul Edici, n={proposalN} için \"{value}\" değerini kabul etti (Teklifçi {proposerId}'den) ve Öğrenici'ye bildirdi.",
            paxosNoAcceptorsAccepted: "[Adım {step}] Paxos: Hiçbir aktif Kabul Edici n={proposalN} için \"{value}\" değerini kabul etmedi.",
            paxosNoAcceptMessage: "[Adım {step}] Paxos: Adım {acceptStep}'den işlenecek ilgili Accept mesajı bulunamadı.",
            paxosNoActiveLearner: "[Adım {step}] Paxos: Aktif Öğrenici bulunamadı.",
            paxosEndOfSimulation: "[Adım {step}] Paxos: Simülasyon adımlarının sonu.",
            paxosWaitingRecovery: "[Adım {step}] Paxos: Teklifçi hatasından sonra kurtarma bekleniyor.",
            paxosWaitingNextPhase: "[Adım {step}] Paxos: Sonraki aşama bekleniyor.",
            paxosLearnerLearned: "[Adım {step}] Paxos: Öğrenici (Düğüm {learnerId}), yeterli çoğunluktan ({count}/{quorum}) \"{value}\" değerini (n={proposalN} ile ilişkili) öğrendi. KONSENSÜS SAĞLANDI (basitleştirilmiş).",
            paxosLearnerWaiting: "[Adım {step}] Paxos: Öğrenici, bir değerin yeterli çoğunluk tarafından kabul edilmesini bekliyor.",
            paxosNoSpecificAction: "[Adım {step}] Paxos: Özel bir eylem tanımlanmadı.",
        }
    },
    en: {
        pageTitle: "Consensus Algorithm Visualizer: Paxos vs Raft",
        languageLabel: "Language:",
        mainTitle: "Consensus Algorithm Visualizer: Paxos vs Raft",
        tabOverview: "Overview",
        tabVisualization: "Visualization",
        tabComparison: "Detailed Comparison",
        overviewTitle: "Understanding Consensus Algorithms: Fundamentals and Technical Need",
        overviewIntro: "In distributed systems, you often need multiple machines to agree on some shared data or state, even when things go wrong like network issues or server crashes. Consensus algorithms solve exactly this problem. They're crucial for things like fault-tolerant databases (think CockroachDB), coordination services (like ZooKeeper or etcd), or deciding the order of transactions in a blockchain. The main idea behind them is often <strong>State Machine Replication (SMR)</strong>: making sure all working copies (replicas) process the same commands in the same order, so they stay in sync and the system remains consistent. <strong>Paxos</strong> is one of the original, theoretically sound algorithms, but it's famously tricky to understand and implement correctly. This difficulty spurred the development of alternatives like <strong>Raft</strong>, which was designed specifically to be easier to grasp and use, making it very popular today. Also, there are other ones too, like <strong>Zab</strong> (used in ZooKeeper) or <strong>Viewstamped Replication (VR)</strong>. These algorithms mainly differ in how they handle core tasks like electing a leader, replicating logs, ensuring safety, and managing message complexity, which impacts their performance and complexity.",
        paxosDesc: "One of the first widely known, theoretically proven consensus algorithms. Flexible but considered difficult to fully understand and implement correctly, especially its Multi-Paxos variant (for log replication).",
        paxosRoles: "<strong>Roles:</strong> Proposer, Acceptor, Learner. Roles can be combined on a single node.",
        paxosProtocol: "<strong>Protocol:</strong> Fundamentally two-phased: Prepare/Promise and Accept/Accepted.",
        paxosLeadership: "<strong>Leadership:</strong> No explicitly defined stable leader, though a 'distinguished' Proposer is often used in practice for performance. Leadership contention and conflicts can occur.",
        paxosComplexity: "<strong>Complexity:</strong> While theoretically strong, correctly handling all edge cases and implementation is difficult.",
        raftDesc: "Designed as an alternative to Paxos, targeting understandability and ease of implementation. Provides a holistic solution for state machine replication.",
        raftRoles: "<strong>Roles:</strong> Leader, Candidate, Follower. Each node is in one of these roles.",
        raftProtocol: "<strong>Protocol:</strong> Main parts are Leader Election, Log Replication, and Safety mechanisms.",
        raftLeadership: "<strong>Leadership:</strong> Strong, single leader. If the leader crashes, a new election process begins. All operations flow through the leader.",
        raftUnderstandability: "<strong>Understandability:</strong> The protocol is decomposed into parts to make it easier to understand.",
        keyCharacteristics: "Key Characteristics Summary",
        tableFeature: "Feature",
        tableLeadership: "Leadership",
        paxosLeadershipVal: "No explicit leader (distinguished proposer used in practice)",
        raftLeadershipVal: "Strong, single, explicit leader",
        tableProtocol: "Protocol Structure",
        paxosProtocolVal: "Two main phases (Prepare/Promise, Accept/Accepted)",
        raftProtocolVal: "Leader election, Log replication, Safety",
        tableFaultTolerance: "Fault Tolerance",
        paxosFaultToleranceVal: "Requires 2f+1 nodes to tolerate f failures",
        raftFaultToleranceVal: "Requires 2f+1 nodes to tolerate f failures",
        tableComplexity: "Implementation Complexity",
        paxosComplexityVal: "High",
        raftComplexityVal: "Medium (easier than Paxos)",
        tableUnderstandability: "Understandability",
        paxosUnderstandabilityVal: "Complex",
        raftUnderstandabilityVal: "Designed for understandability",
        tableMessageComplexity: "Message Complexity",
        paxosMessageComplexityVal: "Potentially more messages in normal case (leaderless)",
        raftMessageComplexityVal: "Fewer messages due to leader (but has heartbeat traffic)",
        tableKeyAdvantage: "Key Advantage",
        paxosKeyAdvantageVal: "Theoretical foundation, flexibility",
        raftKeyAdvantageVal: "Easier to understand and implement",
        goToVisualizationBtn: "Go to Interactive Visualization →",
        disclaimerTitle: "Disclaimer",
        disclaimerText: "This visualization illustrates the basic flow and communication types of Paxos and Raft. The logic of the simulation shown here has been greatly simplified and mechanisms such as timeouts, quorum rules, log matching, dynamic proposal numbers, or detailed failure scenarios are not fully demonstrated. It has been created for conceptual understanding and is not an entirely accurate simulation for implementation in live/production systems.",
        visualizationTitle: "Algorithm Visualization",
        algoComp: "Side by Side",
        algoPaxos: "Paxos Only",
        algoRaft: "Raft Only",
        scenarioLabel: "Scenario:",
        scenarioNormal: "Normal Operation",
        scenarioNodeFailure: "Node Failure (Basic)",
        scenarioLeaderFailure: "Leader/Proposer Failure (Recovery Attempt)",
        stepLabel: "Step:",
        prevBtn: "Prev",
        nextBtn: "Next",
        resetBtn: "Reset",
        legendTitle: "Legend",
        legendPaxosTitle: "Paxos Roles",
        legendProposer: "Proposer",
        legendAcceptor: "Acceptor",
        legendLearner: "Learner",
        legendRaftTitle: "Raft Roles/States",
        legendLeader: "Leader",
        legendCandidate: "Candidate",
        legendFollower: "Follower",
        legendStatesTitle: "Common States",
        legendPreparing: "Preparing (Paxos)",
        legendPromised: "Promised (Paxos)",
        legendAccepted: "Accepted (Paxos)",
        legendFailed: "Failed/Inactive",
        logTitle: "Simulation Logs",
        comparisonTitle: "Detailed Comparison: Paxos vs Raft",
        comparisonIntro: "While both algorithms achieve consensus in distributed systems and tolerate `f` failures with `2f+1` nodes, they differ significantly in their approach, complexity, and operational characteristics.",
        compAspect: "Aspect",
        compLeadership: "Leadership",
        compPaxosLeadershipVal: "No inherent leader. Any proposer can initiate. Often optimized with a \"distinguished proposer\" mimicking a leader, but leadership can change implicitly and contentiously.",
        compRaftLeadershipVal: "Strong, single leader elected explicitly for a given term. All client requests and log replication flow through the leader. Leader failure triggers a new election.",
        compPhases: "Protocol Phases",
        compPaxosPhasesVal: "Phase 1: Prepare/Promise (claiming leadership/proposal number). Phase 2: Accept/Accepted (proposing and confirming the value). Multiple rounds might occur for a single consensus instance.",
        compRaftPhasesVal: "Leader Election (using terms and voting), Log Replication (leader pushes entries to followers via AppendEntries RPCs, including heartbeats), Safety (rules ensuring consistency, e.g., leader completeness).",
        compComplexity: "Complexity & Understandability",
        compPaxosComplexityVal: "High. Considered difficult to understand fully and implement correctly due to subtle interactions and numerous edge cases (e.g., dueling proposers). Multi-Paxos variants add more complexity.",
        compRaftComplexityVal: "Moderate. Designed specifically for understandability. The decomposition into leader election, log replication, and safety makes it easier to grasp and implement.",
        compFaultTolerance: "Fault Tolerance Mechanism",
        compPaxosFaultToleranceVal: "Relies on overlapping quorums (majorities) of acceptors responding to ensure only one value can be chosen. Tolerates node failures and message loss/reordering if quorum is maintained. (Requires 2f+1 nodes to tolerate f failures)",
        compRaftFaultToleranceVal: "Relies on leader election with terms, majority voting for elections, and majority acknowledgment for log entry commitment. Timeouts detect leader failures. Log matching property ensures consistency. (Requires 2f+1 nodes to tolerate f failures)",
        compPerformance: "Performance",
        compPaxosPerformanceVal: "Can potentially achieve consensus faster in stable conditions if a stable leader (distinguished proposer) is established (approaching one round trip). Can suffer performance degradation during proposer conflicts.",
        compRaftPerformanceVal: "Stable performance under a clear leader. Leader election adds latency when failures occur. Log replication overhead depends on the rate of commands.",
        compFlexibility: "Flexibility",
        compPaxosFlexibilityVal: "More flexible in theory; doesn't strictly require a leader. Can potentially handle certain network conditions or failure modes differently.",
        compRaftFlexibilityVal: "Less flexible due to the strong leader model. Simplifies cluster membership changes (though still complex).",
        compUseCases: "Use Cases",
        compPaxosUseCasesVal: "Used in foundational systems like Google's Chubby (based on Paxos), Spanner (uses Paxos-like protocol). Often chosen where theoretical guarantees are paramount or existing expertise exists.",
        compRaftUseCasesVal: "Widely adopted in modern systems like etcd (Kubernetes), Consul, CockroachDB, TiDB. Preferred when ease of understanding, implementation, and maintenance are priorities.",
        advDisadvTitle: "Advantages & Disadvantages",
        advantages: "Advantages:",
        paxosAdv1: "Strong theoretical foundation, mathematically proven.",
        paxosAdv2: "Potentially higher flexibility in network conditions (no strict leader dependency).",
        paxosAdv3: "Can achieve low latency with a stable distinguished proposer.",
        disadvantages: "Disadvantages:",
        paxosDisadv1: "Significantly harder to understand and implement correctly.",
        paxosDisadv2: "Higher message complexity possible, especially during proposer conflicts.",
        paxosDisadv3: "Base Paxos decides on only one value; Multi-Paxos is needed for a log, adding complexity.",
        raftAdv1: "Much easier to understand and implement compared to Paxos.",
        raftAdv2: "Explicit leader simplifies system design and reasoning.",
        raftAdv3: "Provides a complete solution for managing a replicated log.",
        raftAdv4: "Clear mechanisms for handling leader failure and cluster changes (though complex).",
        raftDisadv1: "Leader failure causes temporary unavailability during election.",
        raftDisadv2: "Strong leader dependency might be less optimal in some specific network partition scenarios compared to a leaderless approach.",
        raftDisadv3: "Performance tied to the single leader's capacity.",
        glossaryTitle: "Glossary",
        glossaryNodeIdTitle: "Node Identifiers:",
        glossaryP1Pn: "<strong>P1, Pn...:</strong> Represents nodes (Proposer, Acceptor, Learner) in the Paxos simulation. E.g., P1 is the Paxos node with ID 1.",
        glossaryR1Rn: "<strong>R1, Rn...:</strong> Represents nodes (Follower, Candidate, Leader) in the Raft simulation. E.g., R1 is the Raft node with ID 1.",
        glossaryTermIdTitle: "Term Identifier:",
        glossaryT0Tn: "<strong>T0, Tn...:</strong> Indicates the 'Term' number in the Raft algorithm. Each leader election starts a new term, and the term number increases. E.g., T=1 refers to term 1.",
        glossaryPaxosRolesTitle: "Paxos Roles:",
        glossaryProposer: "<strong>Proposer:</strong> The node that initiates the consensus process and proposes a value.",
        glossaryAcceptor: "<strong>Acceptor:</strong> Nodes that receive, evaluate, and accept proposals. Decisions are made based on a quorum.",
        glossaryLearner: "<strong>Learner:</strong> The node(s) that learn the value chosen by the consensus process.",
        glossaryRaftRolesTitle: "Raft Roles/States:",
        glossaryFollower: "<strong>Follower:</strong> A node passively waiting for messages (AppendEntries/Heartbeat) from the leader and responding to requests from the leader or candidates.",
        glossaryCandidate: "<strong>Candidate:</strong> A node requesting votes during a leader election. Becomes Leader if it receives enough votes.",
        glossaryLeader: "<strong>Leader:</strong> The single node that manages all client requests, replicates log entries to followers, and sends heartbeats.",
        glossaryPaxosMessagesTitle: "Paxos Messages/Concepts:",
        glossaryPrepare: "<strong>Prepare(n=X):</strong> Message sent by a Proposer to Acceptors to start a new proposal round with a specific proposal number (n=X).",
        glossaryPromise: "<strong>Promise(n=X):</strong> A promise made by an Acceptor in response to a Prepare(n=X) message, stating it will not accept proposals with numbers lower than X. It also reports any previously accepted value.",
        glossaryAccept: "<strong>Accept(n=X, v=Y):</strong> An acceptance request sent by the Proposer to Acceptors after receiving enough Promises, with a specific proposal number (n=X) and value (v=Y).",
        glossaryAccepted: "<strong>Accepted(n=X, v=Y):</strong> Message from an Acceptor to Learners indicating it has accepted the Accept request and adopted the value (v=Y) for proposal number (n=X).",
        glossaryRaftMessagesTitle: "Raft Messages/Concepts:",
        glossaryRequestVote: "<strong>RequestVote(term=X):</strong> Message sent by a Candidate to request votes from other nodes for a new leader election. Contains the candidate's term number (term=X).",
        glossaryVoteGranted: "<strong>VoteGranted(term=X, granted=Y):</strong> Response from a node to a RequestVote message, indicating whether the vote was granted (granted=true/false) and its own current term (term=X).",
        glossaryAppendEntries: "<strong>AppendEntries(term=X, entries=[]):</strong> Message sent by the Leader to replicate log entries to followers. If `entries` is empty, it acts as a 'Heartbeat' indicating the leader is alive. Contains the leader's term (term=X).",
        glossaryTerm: "<strong>term=X:</strong> Raft'ta zamanı mantıksal dönemlere (Term) ayıran sayaç. Her seçim yeni bir dönemle başlar ve dönem numarası artar. Bu, eski liderleri veya adayları tespit etmek için kullanılır.",
        glossaryQuorumTitle: "Quorum:",
        glossaryQuorumDesc: "The minimum number of nodes (or votes) required in a distributed system for an operation (like making a decision or electing a leader) to be considered successful and valid. It's typically set to a majority (more than half, > N/2 of the total nodes) to prevent conflicting decisions (split-brain).",
        simulationLogs: {
            raftLeaderFailed: "[Step {step}] Raft: Leader (Node {leaderId}) failed at step {step} due to scenario! Election should start.",
            raftLeaderExists: "[Step {step}] Raft: Leader (Node {leaderId}, Term {term}) exists. Initial election is not needed.",
            raftCandidateElectedSelf: "[Step {step}] Raft: Node {nodeId}'s election timeout expired (simulated). Became Candidate for new Term {term}. Voting for self.",
            raftInitialCandidateInactive: "[Step {step}] Raft: Initial candidate (Node {nodeId}) is not active. Cannot start election.",
            raftLeaderSendsHeartbeats: "[Step {step}] Raft: Leader (Node {leaderId}, Term {term}) is active. Sending heartbeats to maintain authority.",
            raftLeaderSentHeartbeatsCount: "[Step {step}] Raft: Leader {leaderId} sent heartbeats (AppendEntries) to {count} active followers.",
            raftLeaderNoFollowers: "[Step {step}] Raft: Leader {leaderId} has no active followers to send heartbeats to.",
            raftRecoveryCandidateElectedSelf: "[Step {step}] Raft: Recovery - Node {nodeId}'s election timeout expired (simulated after leader failure). Became Candidate for new Term {term}. Voting for self.",
            raftRecoveryNoFollowers: "[Step {step}] Raft: Recovery - No active followers available to start election after leader failure.",
            raftNoLeaderWaiting: "[Step {step}] Raft: No leader exists, but not in recovery scenario (e.g., initial election failed?). Waiting for timeout.",
            raftCandidateRequestingVotes: "[Step {step}] Raft: Candidate {candidateId} (Term {term}) is requesting votes from {count} other active nodes.",
            raftCandidateNoNodesToRequest: "[Step {step}] Raft: Candidate {candidateId} (Term {term}) found no other active nodes to request votes from.",
            raftLeaderExistsNoRequestVote: "[Step {step}] Raft: Leader {leaderId} exists. No RequestVote needed.",
            raftRecoveryNoCandidate: "[Step {step}] Raft: Recovery - No active candidate found to request votes. Waiting for timeout (Step 5 simulation).",
            raftNoCandidateWaiting: "[Step {step}] Raft: No active Candidate found. Waiting for election timeout.",
            raftProcessingRequestVotes: "[Step {step}] Raft: Processing RequestVote messages from step {prevStep}.",
            raftVoterInactive: "[Step {step}] Raft: Voter Node {voterId} is inactive, cannot process RequestVote from {candidateId}.",
            raftCandidateNotFound: "[Step {step}] Raft: Candidate Node {candidateId} not found or inactive, cannot process vote for it.",
            raftVoterUpdatingTerm: "[Step {step}] Raft: Node {voterId} received higher term {newTerm} from Candidate {candidateId}. Updating term from {oldTerm}, becoming Follower.",
            raftVoteGranted: "[Step {step}] Raft: Node {voterId} GRANTED vote to Candidate {candidateId} for Term {term}.",
            raftVoteDenied: "[Step {step}] Raft: Node {voterId} DENIED vote to Candidate {candidateId}. Reason: {reason}.",
            raftVoteDeniedReasonHigherTerm: "Voter's term ({voterTerm}) is higher than candidate's term ({candidateTerm})",
            raftVoteDeniedReasonAlreadyVoted: "Already voted for Node {votedFor} in term {term}",
            raftVoteDeniedReasonGeneric: "Term mismatch or already voted",
            raftCandidateVoteSummary: "[Step {step}] Raft: Candidate {candidateId} has potentially received {count} vote(s) so far in Term {term}.",
            raftNoRequestVotesFound: "[Step {step}] Raft: No RequestVote messages found from step {prevStep}. Election might be stuck or waiting.",
            raftLeaderExistsVoteGrantSkipped: "[Step {step}] Raft: Leader {leaderId} exists. Vote granting phase skipped as no election is active.",
            raftCheckingQuorum: "[Step {step}] Raft: Checking if any candidate received quorum ({quorum} votes) in Term {term} based on votes from step {voteStep}.",
            raftCandidateVoteCheck: "[Step {step}] Raft: Candidate {candidateId} (Term {term}) total votes: {totalVotes} (Received: {receivedVotes}, Self: {selfVote}). Quorum needed: {quorum}.",
            raftNewLeaderElected: "[Step {step}] Raft: Node {leaderId} received quorum ({totalVotes}/{quorum}). Became LEADER for Term {term}.",
            raftRecoveryElectionSuccess: "[Step {step}] Raft: (Recovery election successful!)",
            raftNewLeaderSendsHeartbeats: "[Step {step}] Raft: New Leader {leaderId} sent initial heartbeats to {count} followers.",
            raftNewLeaderNoFollowers: "[Step {step}] Raft: New Leader {leaderId} has no active followers for initial heartbeats.",
            raftCandidateNoQuorum: "[Step {step}] Raft: Candidate {candidateId} did not receive quorum ({totalVotes}/{quorum}). Remains Candidate for now.",
            raftLeaderFailedMaybe: "[Step {step}] Raft: Leader {leaderId} existed but might have failed this step (if scenario=leaderFailure).",
            raftNoQuorumElectionFailed: "[Step {step}] Raft: No candidate received quorum. Election failed for Term {term}. Nodes remain Followers or Candidates.",
            raftNoActiveCandidatesFound: "[Step {step}] Raft: No active candidates were found for Term {term}.",
            raftScenarioTriggerLeaderFail: "[Step {step}] Raft: *** SCENARIO TRIGGER *** Newly elected Leader (Node {leaderId}) is now failing due to scenario!",
            raftLeaderPeriodicHeartbeats: "[Step {step}] Raft: Leader {leaderId} (Term {term}) sending periodic heartbeats to {count} active followers.",
            raftLeaderPeriodicNoFollowers: "[Step {step}] Raft: Leader {leaderId} has no active followers for periodic heartbeats.",
            raftFollowerIgnoringOldHeartbeat: "[Step {step}] Raft: Follower {followerId} received heartbeat from old Leader {leaderId} (Term {leaderTerm} < {followerTerm}). Ignoring.",
            raftFollowerUpdatingTermFromHeartbeat: "[Step {step}] Raft: Follower {followerId} updated term to {newTerm} upon receiving heartbeat from Leader {leaderId}. Resetting votedFor.",
            raftFollowerReceivedHeartbeat: "[Step {step}] Raft: Follower {followerId} received heartbeat from Leader {leaderId}. Remaining follower in Term {term}.",
            raftNoLeaderElectionOngoing: "[Step {step}] Raft: No active Leader found (previously failed at step {failedStep}). Election might be ongoing or failed.",
            raftNoLeaderElectionFailed: "[Step {step}] Raft: No active Leader found. Election process may have failed or waiting for timeout.",
            raftEndOfSimulation: "[Step {step}] Raft: End of simulation steps.",
            raftWaitingNextPhase: "[Step {step}] Raft: Waiting for next phase or action.",
            paxosProposerFailed: "[Step {step}] Paxos: Original Proposer (Node {proposerId}) failed at step {step} due to scenario!",
            paxosRecoveryProposerTakingOver: "[Step {step}] Paxos: Recovery - Node {proposerId} attempting to take over as proposer.",
            paxosPrepareSent: "[Step {step}] Paxos: Proposer (Node {proposerId}) sent Prepare(n={proposalN}) to {count} active acceptors.",
            paxosOriginalProposerFailedOrInactive: "[Step {step}] Paxos: Original proposer failed before step 1 or is inactive.",
            paxosNoActiveInitialProposer: "[Step {step}] Paxos: No active initial Proposer found for step 1.",
            paxosRecoveryProposerPrepareSent: "[Step {step}] Paxos: Recovery Proposer (Node {proposerId}) sent Prepare(n={proposalN}) to {count} active acceptors.",
            paxosRecoveryWaiting: "[Step {step}] Paxos: Recovery - Waiting for a new proposer to emerge or no active node available.",
            paxosOriginalProposerActiveNoAction: "[Step {step}] Paxos: Step 5 - Original proposer is still active. No action defined here.",
            paxosStep5NoAction: "[Step {step}] Paxos: Step 5 - No specific action defined.",
            paxosAcceptorIgnoringPrepare: "[Step {step}] Paxos: Acceptor {acceptorId} ignored Prepare(n={proposalN}) as it already promised {promisedN}.",
            paxosPromisesSent: "[Step {step}] Paxos: {count} Acceptors sent Promise(n={proposalN}) to Node {proposerId}.",
            paxosNoPromisesSent: "[Step {step}] Paxos: No Acceptors sent Promise for n={proposalN}.",
            paxosNoPrepareMessage: "[Step {step}] Paxos: No relevant Prepare message found from step {prepareStep} to respond to.",
            paxosProposerGotQuorum: "[Step {step}] Paxos: Proposer (Node {proposerId}) verified receiving promises from a quorum ({receivedCount}/{quorum}) in step {promiseStep}.",
            paxosProposerNoQuorum: "[Step {step}] Paxos: Proposer (Node {proposerId}) did NOT receive promises from a quorum ({receivedCount}/{quorum}) in step {promiseStep}. Cannot proceed.",
            paxosRecoveryProposerFailedOrNoPrepare: "[Step {step}] Paxos: Recovery proposer (Node {proposerId}) might have failed or prepare was not found.",
            paxosProposerInactive: "[Step {step}] Paxos: Proposer (Node {proposerId}) who sent Prepare in step {prepareStep} is no longer active.",
            paxosAcceptSent: "[Step {step}] Paxos: Proposer (Node {proposerId}) sent Accept(n={proposalN}, v=\"{value}\") to active acceptors.",
            paxosCannotSendAccept: "[Step {step}] Paxos: Cannot send Accept message.",
            paxosAcceptorIgnoringAccept: "[Step {step}] Paxos: Acceptor {acceptorId} ignored Accept(n={proposalN}) as it promised a higher N ({promisedN}).",
            paxosAcceptedAndNotified: "[Step {step}] Paxos: {count} Acceptors accepted value \"{value}\" for n={proposalN} (from Proposer {proposerId}) and notified Learner.",
            paxosNoAcceptorsAccepted: "[Step {step}] Paxos: No active Acceptors accepted the value \"{value}\" for n={proposalN}.",
            paxosNoAcceptMessage: "[Step {step}] Paxos: No relevant Accept message found from step {acceptStep} to process.",
            paxosNoActiveLearner: "[Step {step}] Paxos: No active Learner found.",
            paxosEndOfSimulation: "[Step {step}] Paxos: End of simulation steps.",
            paxosWaitingRecovery: "[Step {step}] Paxos: Waiting for recovery after proposer failure.",
            paxosWaitingNextPhase: "[Step {step}] Paxos: Waiting for next phase.",
            paxosLearnerLearned: "[Step {step}] Paxos: Learner (Node {learnerId}) learned value \"{value}\" (associated with n={proposalN}) from quorum ({count}/{quorum}). CONSENSUS REACHED (simplified).",
            paxosLearnerWaiting: "[Step {step}] Paxos: Learner is waiting for a value to be accepted by a quorum.",
            paxosNoSpecificAction: "[Step {step}] Paxos: No specific action defined.",
        }
    }
};
